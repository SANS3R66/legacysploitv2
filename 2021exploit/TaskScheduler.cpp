#include "TaskScheduler.h"

namespace exploit {
	using Fget_scheduler = int(*)();
	Fget_scheduler get_scheduler = (Fget_scheduler)x(0xFC1050);
}

namespace RBX {
	const char* TaskSchedulerJob::getName() {
		DWORD* job_name = (DWORD*)(this->job_ptr + 16);
		if (*(DWORD*)(this->job_ptr + 36) >= 0x10u) {
			job_name = (DWORD*)*job_name;
		}
		return (char*)job_name;
	}

	DWORD TaskSchedulerJob::getDM() {
		return *(DWORD*)(this->job_ptr + 0x28) + 0x4;
	}

	TaskSchedulerJob* TaskScheduler::findJob(const char* name) {
		DWORD scheduler = exploit::get_scheduler();
		printf("scheduler: %X\n", scheduler);
		
		// jobs_start and jobs_end may be EXACT same sometimes
		 // thats why we covering it with an endless loop
		  // and updating jobs_start, jobs_end
		while (true) {
			DWORD* jobs_start = (DWORD*)*((DWORD*)scheduler + 79);
			DWORD* jobs_end = (DWORD*)*((DWORD*)scheduler + 80);
			while (jobs_start != jobs_end) {
				DWORD job = *jobs_start;
				if (job == NULL) { // bad job ptr
					jobs_start += 2;
					continue;
				}

				DWORD* job_name = (DWORD*)(job + 16);
				if (*(DWORD*)(job + 36) >= 0x10u) {
					job_name = (DWORD*)*job_name; // std::string has a pointer to the char so reading it
				}

				if (strcmp((char*)job_name, name) == 0) {
					TaskSchedulerJob *job_instance = new TaskSchedulerJob(job);
					return job_instance;
				}

				jobs_start += 2;
			}
		}
	}
}