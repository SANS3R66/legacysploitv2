#include <string.h>
#include "TaskScheduler.h"
#include "Instance.h"
#include "RobloxLua.h"

void dll_main() {
    AllocConsole();
    FILE* fDummy;
    freopen_s(&fDummy, "CONOUT$", "w", stdout);
    freopen_s(&fDummy, "CONOUT$", "w", stderr);
    freopen_s(&fDummy, "CONIN$", "r", stdin);

    setvbuf(stdout, NULL, _IONBF, 0);
    setvbuf(stderr, NULL, _IONBF, 0);

    RBX::TaskSchedulerJob *job = RBX::TaskScheduler::findJob("WaitingScriptJob");
    printf("job %s ptr: %X\n", job->getName(), job->job_ptr);
    printf("datamodel ptr: %X\n", job->getDM());

    RBX::Instance* DataModel = new RBX::Instance(job->getDM());
    DWORD *scriptcontextptr = (DWORD*)DataModel->findFirstChildPtr("Script Context");
    printf("scriptcontext ptr: %X\n", (unsigned int)scriptcontextptr);

    // lua global state getter is in ScriptContext::getGlobalState(ScriptContext, identity)
     // currently lua global state:
      // `this[16 * v4 + 45] + this[16 * v4 + 45];`
       // where 'v4' is a boolean; 'this' is a scriptcontext
        // if 'v4' is true or 1, roblox core scripts luavm will be used

    DWORD global_state = (DWORD)&scriptcontextptr[16 * 1 + 45] + scriptcontextptr[16 * 1 + 45];
    printf("global state: %X\n", global_state);
    DWORD rL = r_lua_newthread(global_state);
    printf("thread: %X\n", rL);

    DWORD rL_userdata = *(DWORD*)(rL + 108);
    printf("userdata: %X\n", rL_userdata);
    
    *(DWORD*)(rL_userdata + 24) = 8;

    //r_lua_getfield(rL, -10002, "printidentity"); // current identity is 0 :sob:
    r_lua_getglobal(rL, "printidentity");
    r_lua_call(rL, 0, 0);
}

BOOL APIENTRY DllMain( HMODULE hModule,
                       DWORD   ul_reason_for_call,
                       LPVOID  lpReserved
                     )
{
    switch (ul_reason_for_call)
    {
    case DLL_PROCESS_ATTACH:
        DisableThreadLibraryCalls(hModule);
        CreateThread(nullptr, 0x1000, (LPTHREAD_START_ROUTINE)dll_main, nullptr, 0, nullptr);
        break;
    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:
    case DLL_PROCESS_DETACH:
        break;
    }
    return TRUE;
}

